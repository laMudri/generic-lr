\begin{code}
{-# OPTIONS --safe --without-K --postfix-projections #-}
module Generic.Simple.Syntax (Ty : Set) where

  open import Data.LTree
  open import Data.LTree.Vector
  open import Data.Product
  open import Data.Unit.Polymorphic
  open import Level
  open import Relation.Unary using (_⊢_)
  open import Relation.Unary.Checked
  open import Relation.Binary.PropositionalEquality hiding ([_])

  infix 1 _`⊆_ _▹_
  infixr 2 _`∧_

  private
    variable
      t u x y : Level

  record Ctx : Set where
    constructor ctx
    field
      {shape} : LTree
      ty-ctx : Vector Ty shape
  open Ctx public

  []ᶜ : Ctx
  []ᶜ = ctx []

  [_]ᶜ : Ty → Ctx
  [ A ]ᶜ = ctx [ A ]

  _++ᶜ_ : Ctx → Ctx → Ctx
  ctx Γ ++ᶜ ctx Δ = ctx (Γ ++ Δ)
\end{code}

%<*SimplePremises>
\begin{code}
  data Premises : Set where
    ⟨_`⊢_⟩ : (Γ : Ctx) (A : Ty) → Premises
    `⊤ : Premises
    _`∧_ : (p q : Premises) → Premises
\end{code}
%</SimplePremises>

\begin{code}
  record Rule : Set where
    constructor _`⊆_
    field
      premises : Premises
      conclusion : Ty
  open Rule public

  record System : Set₁ where
    constructor _▹_
    field
      Label : Set
      rules : (l : Label) → Rule
  open System public

  OpenFam : Set (suc 0ℓ)
  OpenFam = Ctx → Ty → Set

  Scope : OpenFam → Ctx → OpenFam
  Scope T Δ Γ A = T (Γ ++ᶜ Δ) A
\end{code}

\begin{code}
  module WithScope (
\end{code}
%<*WithScope>
\begin{code}[inline]
    ,_⟦_⊢_⟧ : Ctx → OpenFam
\end{code}
%</WithScope>
\begin{code}
    ) where
\end{code}

%<*semp>
\begin{code}
    ⟦_⟧p : Premises → Ctx → Set
    ⟦ ⟨ Δ `⊢ A ⟩ ⟧p Γ = , Δ ⟦ Γ ⊢ A ⟧
    ⟦ `⊤ ⟧p = U
    ⟦ p `∧ q ⟧p = ⟦ p ⟧p ∩ ⟦ q ⟧p
\end{code}
%</semp>

%<*semr>
\begin{code}
    ⟦_⟧r : Rule → OpenFam
    ⟦ ps `⊆ A′ ⟧r Γ A = A′ ≡ A × ⟦ ps ⟧p Γ
\end{code}
%</semr>

%<*sems>
\begin{code}
    ⟦_⟧s : System → OpenFam
    ⟦ L ▹ rs ⟧s Γ A = Σ[ l ∈ L ] ⟦ rs l ⟧r Γ A
\end{code}
%</sems>

\begin{code}
  ⟦_⟧p : Premises → (Ctx → OpenFam) → (Ctx → Set)
  ⟦ ps ⟧p Sc = let module W = WithScope Sc in W.⟦ ps ⟧p

  ⟦_⟧r : Rule → (Ctx → OpenFam) → OpenFam
  ⟦ r ⟧r Sc = let module W = WithScope Sc in W.⟦ r ⟧r

  ⟦_⟧s : System → (Ctx → OpenFam) → OpenFam
  ⟦ s ⟧s Sc = let module W = WithScope Sc in W.⟦ s ⟧s
\end{code}

\begin{code}
  module _ {Γ Δ : Ctx} {X : Ctx → OpenFam} {Y : Ctx → OpenFam} where

    map-p : (ps : Premises) →
      (∀ {Θ A} → X Θ Γ A → Y Θ Δ A) →
      (⟦ ps ⟧p X Γ → ⟦ ps ⟧p Y Δ)
    map-p ⟨ Θ `⊢ A ⟩ f t = f t
    map-p `⊤ f _ = _
    map-p (ps `∧ qs) f (s , t) = map-p ps f s , map-p qs f t

    map-r : (r : Rule) →
      (∀ {Θ A} → X Θ Γ A → Y Θ Δ A) →
      (∀ {A} → ⟦ r ⟧r X Γ A → ⟦ r ⟧r Y Δ A)
    map-r (ps `⊆ A) f (q , t) = q , map-p ps f t
\end{code}

%<*map-s-type>
\begin{code}
    map-s : (s : System) →
      (∀ {Θ A} → X Θ Γ A → Y Θ Δ A) →
      (∀ {A} → ⟦ s ⟧s X Γ A → ⟦ s ⟧s Y Δ A)
\end{code}
%</map-s-type>
\begin{code}
    map-s (L ▹ rs) f (l , t) = l , map-r (rs l) f t
\end{code}
