\begin{code}
{-# OPTIONS --safe --without-K --postfix-projections #-}

module Generic.Linear.Example.ZeroOneMany where

  open import Algebra.Po
  open import Algebra.Skew
  open import Data.Bool.Base using (Bool; true; false)
  open import Data.Bool.Extra
  open import Data.List
  open import Data.Product
  open import Data.Unit using (⊤; tt)
  open import Function.Base
  open import Level using (0ℓ)
  open import Relation.Binary.PropositionalEquality as ≡ using
    (_≡_; refl; trans; sym; isEquivalence)
  open import Relation.Unary.Bunched

  infix 7 _*_
  infix 6 _+_
  infix 4 _≤_

  data 0#1ω : Set where
    0# 1# ω# : 0#1ω

  data _≤_ : (a b : 0#1ω) → Set where
    ≤-refl : ∀ {a} → a ≤ a
    ω≤0 : ω# ≤ 0#
    ω≤1 : ω# ≤ 1#

  _+_ : (a b : 0#1ω) → 0#1ω
  0# + b = b
  1# + 0# = 1#
  1# + 1# = ω#
  1# + ω# = ω#
  ω# + b = ω#

  _*_ : (a b : 0#1ω) → 0#1ω
  0# * b = 0#
  1# * b = b
  ω# * 0# = 0#
  ω# * 1# = ω#
  ω# * ω# = ω#

  rawSkewSemiring : RawSkewSemiring 0ℓ 0ℓ
  rawSkewSemiring = record
    { rawProset = record { Carrier = 0#1ω; _≤_ = _≤_ }
    ; 0# = 0#
    ; _+_ = _+_
    ; 1# = 1#
    ; _*_ = _*_
    }

  rawPoSemiring : RawPoSemiring 0ℓ 0ℓ 0ℓ
  rawPoSemiring = record
    { rawPoset = record { Carrier = 0#1ω ; _≈_ = _≡_ ; _≤_ = _≤_ }
    ; RawSkewSemiring rawSkewSemiring
    }

  ≤-trans : ∀ {x y z} → x ≤ y → y ≤ z → x ≤ z
  ≤-trans ≤-refl yz = yz
  ≤-trans ω≤0 ≤-refl = ω≤0
  ≤-trans ω≤1 ≤-refl = ω≤1

  ω#≤ : ∀ {x} → ω# ≤ x
  ω#≤ {0#} = ω≤0
  ω#≤ {1#} = ω≤1
  ω#≤ {ω#} = ≤-refl

  +-mono : ∀ {x x′ y y′} → x ≤ x′ → y ≤ y′ → x + y ≤ x′ + y′
  +-mono ≤-refl ≤-refl = ≤-refl
  +-mono {x = 0#} ≤-refl ω≤0 = ω≤0
  +-mono {x = 1#} ≤-refl ω≤0 = ω≤1
  +-mono {x = ω#} ≤-refl ω≤0 = ≤-refl
  +-mono {x = 0#} ≤-refl ω≤1 = ω≤1
  +-mono {x = 1#} ≤-refl ω≤1 = ≤-refl
  +-mono {x = ω#} ≤-refl ω≤1 = ≤-refl
  +-mono ω≤0 ≤-refl = ω#≤
  +-mono ω≤0 ω≤0 = ω≤0
  +-mono ω≤0 ω≤1 = ω≤1
  +-mono ω≤1 ≤-refl = ω#≤
  +-mono ω≤1 ω≤0 = ω≤1
  +-mono ω≤1 ω≤1 = ≤-refl

  *-mono : ∀ {x x′ y y′} → x ≤ x′ → y ≤ y′ → x * y ≤ x′ * y′
  *-mono ≤-refl ≤-refl = ≤-refl
  *-mono {x = 0#} ≤-refl ω≤0 = ≤-refl
  *-mono {x = 1#} ≤-refl ω≤0 = ω≤0
  *-mono {x = ω#} ≤-refl ω≤0 = ω≤0
  *-mono {x = 0#} ≤-refl ω≤1 = ≤-refl
  *-mono {x = 1#} ≤-refl ω≤1 = ω≤1
  *-mono {x = ω#} ≤-refl ω≤1 = ≤-refl
  *-mono {y = 0#} ω≤0 yy = ≤-refl
  *-mono {y = 1#} ω≤0 yy = ω≤0
  *-mono {y = ω#} ω≤0 yy = ω≤0
  *-mono {y = 0#} ω≤1 yy = yy
  *-mono {y = 1#} ω≤1 yy = ω#≤
  *-mono {y = ω#} ω≤1 yy = ω#≤

  ≡⇒≤ : ∀ {x y} → x ≡ y → x ≤ y
  ≡⇒≤ refl = ≤-refl

  +-identityʳ : ∀ x → x + 0# ≡ x
  +-identityʳ 0# = refl
  +-identityʳ 1# = refl
  +-identityʳ ω# = refl

  +-assoc : ∀ x y z → (x + y) + z ≡ x + (y + z)
  +-assoc 0# y z = refl
  +-assoc 1# 0# z = refl
  +-assoc 1# 1# 0# = refl
  +-assoc 1# 1# 1# = refl
  +-assoc 1# 1# ω# = refl
  +-assoc 1# ω# z = refl
  +-assoc ω# y z = refl

  +-comm : ∀ x y → x + y ≡ y + x
  +-comm 0# 0# = refl
  +-comm 0# 1# = refl
  +-comm 0# ω# = refl
  +-comm 1# 0# = refl
  +-comm 1# 1# = refl
  +-comm 1# ω# = refl
  +-comm ω# 0# = refl
  +-comm ω# 1# = refl
  +-comm ω# ω# = refl

  *-identityʳ : ∀ x → x ≡ x * 1#
  *-identityʳ 0# = refl
  *-identityʳ 1# = refl
  *-identityʳ ω# = refl

  *-assoc : ∀ x y z → (x * y) * z ≡ x * (y * z)
  *-assoc 0# y z = refl
  *-assoc 1# y z = refl
  *-assoc ω# 0# z = refl
  *-assoc ω# 1# z = refl
  *-assoc ω# ω# 0# = refl
  *-assoc ω# ω# 1# = refl
  *-assoc ω# ω# ω# = refl

  annihilʳ : ∀ x → 0# ≡ x * 0#
  annihilʳ 0# = refl
  annihilʳ 1# = refl
  annihilʳ ω# = refl

  distribˡ : ∀ x y z → (x + y) * z ≡ x * z + y * z
  distribˡ 0# y z = refl
  distribˡ 1# 0# 0# = refl
  distribˡ 1# 0# 1# = refl
  distribˡ 1# 0# ω# = refl
  distribˡ 1# 1# 0# = refl
  distribˡ 1# 1# 1# = refl
  distribˡ 1# 1# ω# = refl
  distribˡ 1# ω# 0# = refl
  distribˡ 1# ω# 1# = refl
  distribˡ 1# ω# ω# = refl
  distribˡ ω# 0# 0# = refl
  distribˡ ω# 1# 0# = refl
  distribˡ ω# ω# 0# = refl
  distribˡ ω# y 1# = refl
  distribˡ ω# y ω# = refl

  distribʳ : ∀ x y z → x * y + x * z ≡ x * (y + z)
  distribʳ 0# y z = refl
  distribʳ 1# y z = refl
  distribʳ ω# 0# z = refl
  distribʳ ω# 1# 0# = refl
  distribʳ ω# 1# 1# = refl
  distribʳ ω# 1# ω# = refl
  distribʳ ω# ω# z = refl

  antisym : ∀ {x y} → x ≤ y → y ≤ x → x ≡ y
  antisym ≤-refl yx = refl
  antisym ω≤0 ()
  antisym ω≤1 ()

  poSemiring : PoSemiring 0ℓ 0ℓ 0ℓ
  poSemiring = record
    { RawPoSemiring rawPoSemiring
    ; isPoSemiring = record
      { isPartialOrder = record
        { isPreorder = record
          { isEquivalence = isEquivalence
          ; reflexive = ≡⇒≤
          ; trans = ≤-trans
          }
        ; antisym = antisym
        }
      ; isSemiring = record
        { isSemiringWithoutAnnihilatingZero = record
          { +-isCommutativeMonoid = record
            { isMonoid = record
              { isSemigroup = record
                { isMagma = record
                  { isEquivalence = isEquivalence
                  ; ∙-cong = ≡.cong₂ _
                  }
                ; assoc = +-assoc
                }
              ; identity = λ- refl , +-identityʳ
              }
            ; comm = +-comm
            }
          ; *-cong = ≡.cong₂ _
          ; *-assoc = *-assoc
          ; *-identity = λ- refl , sym ∘ *-identityʳ
          ; distrib = (λ x y z → sym (distribʳ x y z))
                    , (λ x y z → distribˡ y z x)
          }
        ; zero = λ- refl , sym ∘ annihilʳ
        }
      ; +-mono = +-mono
      ; *-mono = *-mono
      }
    }
  open PoSemiring poSemiring public using (≤-reflexive)

  skewSemiring : SkewSemiring 0ℓ 0ℓ
  skewSemiring = record
    { proset = record
      { _≤_ = _≤_
      ; isProset = record { refl = ≤-refl ; trans = ≤-trans }
      }
    ; 0# = 0#
    ; plus = record { _∙_ = _+_ ; mono = +-mono }
    ; 1# = 1#
    ; mult = record { _∙_ = _*_ ; mono = *-mono }
    ; isSkewSemiring = record
      { +-isSkewCommutativeMonoid = record
        { isLeftSkewMonoid = record
          { identity = λ- ≤-refl , ≡⇒≤ ∘ sym ∘ +-identityʳ
          ; assoc = λ x y z → ≡⇒≤ (+-assoc x y z)
          }
        ; isRightSkewMonoid = record
          { identity = λ- ≤-refl , ≡⇒≤ ∘ +-identityʳ
          ; assoc = λ x y z → ≡⇒≤ (sym (+-assoc x y z))
          }
        ; comm = λ x y → ≡⇒≤ (+-comm x y)
        }
      ; *-isSkewMonoid = record
        { identity = λ- ≤-refl , ≡⇒≤ ∘ *-identityʳ
        ; assoc = λ x y z → ≡⇒≤ (*-assoc x y z)
        }
      ; annihil = λ- ≤-refl , ≡⇒≤ ∘ annihilʳ
      ; distrib = (λ x y z → ≡⇒≤ (distribˡ x y z))
                , (λ x y z → ≡⇒≤ (distribʳ x y z))
      }
    }
\end{code}

%<*0-inv>
\begin{code}
  0#⁻¹ : ∀ x → List (x ≤ 0#)
  0#⁻¹ 0# = ≤-refl ∷ []
  0#⁻¹ 1# = []
  0#⁻¹ ω# = ω≤0 ∷ []
\end{code}
%</0-inv>

%<*plus-inv>
\begin{code}
  +⁻¹ : ∀ x → List (∃ \ ((y , z) : _ × _) → x ≤ y + z)
  +⁻¹ 0# = ((0# , 0#) , ≤-refl) ∷ []
  +⁻¹ 1# = ((1# , 0#) , ≤-refl) ∷ ((0# , 1#) , ≤-refl) ∷ []
  +⁻¹ ω# = ((ω# , ω#) , ≤-refl) ∷ []
\end{code}
%</plus-inv>

%<*1-inv>
\begin{code}
  1#⁻¹ : ∀ x → List (x ≤ 1#)
  1#⁻¹ 0# = []
  1#⁻¹ 1# = ≤-refl ∷ []
  1#⁻¹ ω# = ω≤1 ∷ []
\end{code}
%</1-inv>

%<*mult-inv>
\begin{code}
  *⁻¹ : ∀ x z → List (∃ \ y → z ≤ x * y)
  *⁻¹ 0# 0# = (ω# , ≤-refl) ∷ []
  *⁻¹ 0# 1# = []
  *⁻¹ 0# ω# = []
  *⁻¹ 1# z = (z , ≤-refl) ∷ []
  *⁻¹ ω# 0# = (0# , ≤-refl) ∷ []
  *⁻¹ ω# 1# = []
  *⁻¹ ω# ω# = (ω# , ≤-refl) ∷ []
\end{code}
%</mult-inv>

\begin{code}
  open Duplicable _≤_ (_≤ 0#) (λ x y z → x ≤ y + z) (λ x y z → x ≤ y * z)
    hiding (mkDup)
  rep : ∀ x → List (∃ (Dup x))
  rep 0# = (_ , mkDup ≤-refl ≤-refl ≤-refl (≡⇒≤ ∘ annihilʳ)) ∷ []
  rep 1# = []
  rep ω# = (_ , mkDup ≤-refl ω≤0 ≤-refl lemma) ∷ []
    where
    lemma : ∀ r → ω# ≤ r * ω#
    lemma 0# = ω≤0
    lemma 1# = ≤-refl
    lemma ω# = ≤-refl

  ω*-del : ∀ x → ω# * x ≤ 0#
  ω*-del 0# = ≤-refl
  ω*-del 1# = ω≤0
  ω*-del ω# = ω≤0

  ω*-dup : ∀ x → ω# * x ≤ ω# * x + ω# * x
  ω*-dup 0# = ≤-refl
  ω*-dup 1# = ≤-refl
  ω*-dup ω# = ≤-refl

  ω*-cojoin : ∀ x → ω# * x ≤ ω# * (ω# * x)
  ω*-cojoin 0# = ≤-refl
  ω*-cojoin 1# = ≤-refl
  ω*-cojoin ω# = ≤-refl

  ω*-scl : ∀ x r → ω# * x ≤ r * (ω# * x)
  ω*-scl x 0# = ω*-del x
  ω*-scl x 1# = ≤-refl
  ω*-scl x ω# = ω*-cojoin x

  ω*-≤ : ∀ x → ω# * x ≤ x
  ω*-≤ 0# = ≤-refl
  ω*-≤ 1# = ω≤1
  ω*-≤ ω# = ≤-refl

  ≤0-dup : ∀ {x} → x ≤ 0# → x ≤ x + x
  ≤0-dup ≤-refl = ≤-refl
  ≤0-dup ω≤0 = ≤-refl

  ≤0-scl : ∀ {x r} → x ≤ 0# → x ≤ r * x
  ≤0-scl {r = r} ≤-refl = ≡.subst (_≤ r * 0#) (≡.sym (annihilʳ r)) ≤-refl
  ≤0-scl ω≤0 = ω#≤

  *-comm : ∀ x y → x * y ≡ y * x
  *-comm 0# y = annihilʳ y
  *-comm 1# y = *-identityʳ y
  *-comm ω# 0# = refl
  *-comm ω# 1# = refl
  *-comm ω# ω# = refl
\end{code}
