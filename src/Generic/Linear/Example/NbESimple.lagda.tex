\begin{code}
{-# OPTIONS --sized-types --without-K --prop --postfix-projections #-}

open import Algebra.Po
open import Level hiding (zero)

module Generic.Linear.Example.NbESimple (poSemiring : PoSemiring 0â„“ 0â„“ 0â„“) where

  open PoSemiring poSemiring renaming (Carrier to Ann) using ()

  open import Data.LTree
  open import Data.LTree.Vector
  open import Data.Product
  open import Data.Wrap renaming ([_] to mk)
  open import Function hiding (_âˆ‹_)
  open import Function.Extra
  open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl)
  open import Relation.Unary.Bunched
  open import Size

  infixr 50 _âŠ¸_
  infix 20 _âŠ¨_
\end{code}

%<*Ty>
\begin{code}
  data Ty : Set where
    Î¹ : Ty
    _âŠ¸_ : (rA : Ann Ã— Ty) (B : Ty) â†’ Ty
\end{code}
%</Ty>

\begin{code}
  open import Generic.Linear.Everything Ty poSemiring
    hiding (Ann; lift; âŸ¨_âŸ©Â·_; refl)
  -- open module Dummy {s} = PoLeftSemimodule (Vá´¾ s)
\end{code}

%<*system>
\begin{code}
  data L : Set where
    `app `lam : (rA : Ann Ã— Ty) (B : Ty) â†’ L

  system : System
  system = L â–¹ Î» where
    (`app rA@(r , A) B) â†’ âŸ¨ []á¶œ `âŠ¢ rA âŠ¸ B âŸ© `âœ´ r `Â· âŸ¨ []á¶œ `âŠ¢ A âŸ© `âŠ† B
    (`lam rA B) â†’ âŸ¨ [ rA ]á¶œ `âŠ¢ B âŸ© `âŠ† rA âŠ¸ B

  Term = [ system , âˆ ]_âŠ¢_
\end{code}
%</system>

\begin{code}
  open Semantics
\end{code}

%<*vDash>
\begin{code}
  _âŠ¨_ : OpenFam (suc 0â„“)
  Î“ âŠ¨ Î¹ = Lift (suc 0â„“) (Term Î“ Î¹)
  Î“ âŠ¨ (r , A) âŠ¸ B = â–¡Ê³ ((r Â· _âŠ¨ A) â”€âœ´ _âŠ¨ B) Î“
\end{code}
%</vDash>

\begin{code}
  ren^âŠ¨ : âˆ€ {A} â†’ Renameable (_âŠ¨ A)
  ren^âŠ¨ {Î¹} (lift M) Ï = lift (ren^âŠ¢ M Ï)
  ren^âŠ¨ {rA âŠ¸ B} b = ren^â–¡ b
\end{code}

\begin{code}
  open With-psh^ğ“¥ {ğ“¥ = _âŠ¨_} (renâ‡’psh (Î» {A} â†’ ren^âŠ¨ {A}))
\end{code}

%<*evalSem>
\begin{code}
  evalSem : Semantics system _âŠ¨_ _âŠ¨_
  evalSem .ren^ğ“¥ {A} = ren^âŠ¨ {A}
  evalSem .âŸ¦varâŸ§ = id
  evalSem .âŸ¦conâŸ§ (`app _ _ , refl , M âœ´âŸ¨ sp+ âŸ© (âŸ¨ sp* âŸ©Â· N)) =
    reify[] M 1Ê³ .appâœ´ sp+ (âŸ¨ sp* âŸ©Â· reify[] N)
  evalSem .âŸ¦conâŸ§ (`lam _ _ , refl , M) Ï .appâœ´ sp+ [N] =
    M .get Ï .appâœ´ sp+ ([-]áµ‰ [N])
\end{code}
%</evalSem>

%<*eval>
\begin{code}
  eval : âˆ€ {Î“ Î”} â†’ [ _âŠ¨_ ] Î“ â‡’áµ‰ Î” â†’ {A : Ty} â†’ Term Î” A â†’ Î“ âŠ¨ A
  eval Ï M = semantics evalSem Ï M
\end{code}
%</eval>

%<*reify-reflect>
\begin{code}
  nbeReify : âˆ€ {Î“} A â†’ Î“ âŠ¨ A â†’ Term Î“ A
  nbeReflect : âˆ€ {Î“} A â†’ Term Î“ A â†’ Î“ âŠ¨ A

  nbeReify Î¹ (lift v) = v
  nbeReify ((r , A) âŠ¸ B) v =
    `con (`lam _ _ , refl ,
      nbeReify B (v â†™Ê³ .appâœ´ (mká¶œ sp+) (âŸ¨ sp* âŸ©Â·á¶œ
        nbeReflect A (`var (lvar (â†˜ here) refl (â‰¤*-refl ++â‚™ [ â‰¤-refl ]â‚™))))))
    where
    sp+ : âˆ€ {s t} {P : Vector Ann s} {Q : Vector Ann t} â†’
      (P ++ Q) â‰¤[ (P ++ 0*) +* (0* ++ Q) ]
    sp+ = +*-identityâ†˜ _ ++â‚™ +*-identityâ†™ _

    sp* : âˆ€ {s r} â†’ (0* {s} ++ [ r ]) â‰¤[ r *â‚— (0* ++ [ 1# ]) ]
    sp* = (mk Î» _ â†’ â‰¤-reflexive (sym (annihilÊ³ _))) ++â‚™ [ *.identity .projâ‚‚ _ ]â‚™

  nbeReflect Î¹ M = lift M
  nbeReflect ((r , A) âŠ¸ B) M Ï .appâœ´ (mká¶œ sp+) (âŸ¨ sp* âŸ©Â·á¶œ N) =
    nbeReflect B (`con (`app _ _ , refl ,
      ren (â†™Ê³â€² []â‚™ >>Ê³ Ï) M âœ´á¶œâŸ¨ sp+ âŸ© âŸ¨ sp* âŸ©Â·á¶œ nbeReify A (ren^âŠ¨ N (â†™Ê³â€² []â‚™))))
\end{code}
%</reify-reflect>

%<*nbe>
\begin{code}
  instance
    identityEnv^âŠ¨ : IdentityEnv _âŠ¨_
    identityEnv^âŠ¨ .pure x = nbeReflect _ (`var x)

  nbe : âˆ€ {Î“ A} â†’ Term Î“ A â†’ Term Î“ A
  nbe M = nbeReify _ (eval id^Env M)
\end{code}
%</nbe>
