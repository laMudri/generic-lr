\begin{code}
{-# OPTIONS --sized-types --without-K --postfix-projections --prop #-}

module Generic.Linear.Example.MuMuTilde.Term (Base : Set) where

  open import Algebra.Po
  open import Data.LTree
  open import Data.LTree.Automation
  open import Data.LTree.Vector
  open import Data.Product
  open import Level using (0ℓ)
  open import Relation.Binary.PropositionalEquality as ≡ using (_≡_)
  open import Relation.Unary.Bunched
  open import Size

  open import Generic.Linear.Example.ZeroOneMany
    using (poSemiring; 0#⁻¹; +⁻¹; 1#⁻¹; *⁻¹; rep)
  open import Generic.Linear.Example.MuMuTilde poSemiring Base
  open import Generic.Linear.Everything Conc poSemiring
  open import Generic.Linear.Example.UsageCheck Conc
  open WithPoSemiring poSemiring
  open WithInverses
    record { 0#⁻¹ = 0#⁻¹ ; +⁻¹ = +⁻¹ ; 1#⁻¹ = 1#⁻¹ ; *⁻¹ = *⁻¹ ; rep = rep }
\end{code}

%<*patterns>
\begin{code}
  pattern ucut v e = U.`con (`cut _ , ≡.refl , v ✴ᶜ⟨ _ ⟩ e)
  pattern uμ c = U.`con (`μ _ , ≡.refl , c)
  pattern uμ∼ c = U.`con (`μ∼ _ , ≡.refl , c)
  pattern uλ e = U.`con (`λ _ , ≡.refl , e)
  pattern uλ∼ v = U.`con (`λ _ , ≡.refl , v)
  pattern u⟨_,_⟩ e f =
    U.`con (`⟨-,-⟩ _ _ , ≡.refl , (⟨ _ ⟩·ᶜ e) ✴ᶜ⟨ _ ⟩ (⟨ _ ⟩·ᶜ f))
  pattern uμ⟨-,-⟩ c = U.`con (`μ⟨-,-⟩ _ _ , ≡.refl , c)
\end{code}
%</patterns>

%<*myComm>
\begin{code}
  myComm : (A B : Ty) → let 1A = 1# , A; 1B = 1# , B in
    [ MMT , ∞ ] []ᶜ ⊢ trm ((1# , (1A ⅋ 1B) ^⊥) ⅋ (1# , 1B ⅋ 1A))
  myComm A B = elab-unique MMT
    (uμ⟨-,-⟩ (ucut
      (uμ⟨-,-⟩ (ucut (uλ u⟨ uvar #3 , uvar #2 ⟩) (uvar (# 0))))
      (uvar (# 1))))
    []
    where
    #3 = ↙ (↙ (↙ (↘ (↘ here))))
    #2 = ↙ (↙ (↙ (↘ (↙ here))))
\end{code}
%</myComm>
\begin{code}
    -- (uμ⟨-,-⟩ (ucut
    --   (uμ⟨-,-⟩ (ucut (uλ u⟨ uvar (# 3) , uvar (# 2) ⟩) (uvar (# 0))))
    --   (uvar (# 1))))
\end{code}
