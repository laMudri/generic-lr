\begin{code}
{-# OPTIONS --sized-types --without-K --postfix-projections #-}

module Generic.Linear.Example.ZeroOneMany.LinIntView where

  open import Generic.Linear.Example.ZeroOneMany renaming (0#1ω to Ann)

  open import Data.Bool using (Bool; true; false; if_then_else_)
  open import Data.Product
  open import Function.Base using (case_of_)
  open import Relation.Binary.PropositionalEquality
\end{code}

%<*Linear>
\begin{code}
  data Linear : Ann → Set where
    0#-lin : Linear 0#
    1#-lin : Linear 1#
\end{code}
%</Linear>

\begin{code}
  linear-≤ : ∀ {x y} → x ≤ y → Linear x → Linear y
  linear-≤ ≤-refl l = l

  linear-summands : ∀ {z x y} → z ≤ x + y → Linear z → Linear x × Linear y
  linear-summands {0#} {0#} {.0#} ≤-refl 0#-lin = 0#-lin , 0#-lin
  linear-summands {0#} {1#} {0#} () 0#-lin
  linear-summands {0#} {1#} {1#} () 0#-lin
  linear-summands {0#} {1#} {ω#} () 0#-lin
  linear-summands {1#} {0#} {.1#} ≤-refl 1#-lin = 0#-lin , 1#-lin
  linear-summands {1#} {1#} {0#} le 1#-lin = 1#-lin , 0#-lin

  linear-/ω : ∀ {z y} → z ≤ ω# * y → Linear z → Linear y
  linear-/ω {z} {0#} le l = 0#-lin
  linear-/ω {z} {1#} le l = 1#-lin
  linear-/ω {.(ω# * ω#)} {ω#} ≤-refl ()
\end{code}

%<*LIView>
\begin{code}
  data LIView : Ann → Set where
    view-lin : ∀ {x} (l : Linear x) → LIView x
    view-int : LIView ω#
\end{code}
%</LIView>

%<*liview-type>
\begin{code}[inline]
  liview : ∀ x → LIView x
\end{code}
%</liview-type>
\begin{code}
  liview 0# = view-lin 0#-lin
  liview 1# = view-lin 1#-lin
  liview ω# = view-int
\end{code}

\begin{code}
  liview-prop : ∀ {x} (u v : LIView x) → u ≡ v
  liview-prop view-int view-int = refl
  liview-prop (view-lin 0#-lin) (view-lin 0#-lin) = refl
  liview-prop (view-lin 1#-lin) (view-lin 1#-lin) = refl

  is-lin : Ann → Bool
  is-lin x = case liview x of λ where
    view-int → false
    (view-lin _) → true
\end{code}
