{-# OPTIONS --sized-types --without-K --postfix-projections --prop #-}

open import Algebra.Po
open import Level using (0‚Ñì)
open import Relation.Binary using (Rel)

module Generic.Linear.Example.AnnotatedArrow
  (poSemiring : PoSemiring 0‚Ñì 0‚Ñì 0‚Ñì) (Base : Set)
  where

  open PoSemiring poSemiring hiding (setoid) renaming (Carrier to Ann)

  open import Algebra.Relational
  open import Data.LTree
  open import Data.LTree.Vector hiding (setoid)
  open import Data.LTree.Matrix
  open import Data.Product as √ó
  open import Data.Product.Relation.Binary.Pointwise.NonDependent as √óPW
    using (√ó-setoid)
  open import Data.Unit using (‚ä§; tt)
  open import Data.Wrap
  open import Function.Base using (id; _‚àò_; _‚àò‚Ä≤_; _$_; Œª-; _$-)
  open import Function.Equality using (_‚ü∂_; _‚á®_; _‚ü®$‚ü©_; cong)
  open import Proposition
  open import Size
  open import Relation.Nary
  open import Relation.Unary.Checked as Chk using (Pred)
  open import Relation.Unary.Bunched.Checked
  open import Relation.Unary.Bunched.Properties
  open import Relation.Binary using (Setoid)
  open import Relation.Binary.Construct.Always as ‚ä§ using ()
  open import Relation.Binary.PropositionalEquality as ‚â° using (_‚â°_)

  infixr 5 _‚ä∏_

  data Ty : Set where
    base : Ty
    _‚ä∏_ : (rA : Ann √ó Ty) (B : Ty) ‚Üí Ty

  open import Generic.Linear.Operations rawPoSemiring
  open import Generic.Linear.Algebra poSemiring
  open import Generic.Linear.Syntax Ty Ann
  open import Generic.Linear.Syntax.Interpretation Ty rawPoSemiring
  open import Generic.Linear.Syntax.Interpretation.Map Ty poSemiring
  open import Generic.Linear.Syntax.Term Ty rawPoSemiring
  open import Generic.Linear.Variable Ty rawPoSemiring
  open import Generic.Linear.Environment Ty poSemiring
  open import Generic.Linear.Renaming Ty poSemiring
  open [_]_‚áí·µâ_
  open import Generic.Linear.Extend Ty poSemiring
  open import Generic.Linear.Renaming.Properties Ty poSemiring
  open import Generic.Linear.Environment.Properties Ty poSemiring
  open import Generic.Linear.Semantics Ty poSemiring

  data `AnnArr : Set where
    `lam `app : (rA : Ann √ó Ty) (B : Ty) ‚Üí `AnnArr

  flags : PremisesFlags
  flags = record noPremisesFlags { Has-‚ú¥ = ‚ä§·¥æ ; Has-¬∑ = ‚ä§·¥æ }

  AnnArr : System flags
  AnnArr = `AnnArr ‚ñπ Œª where
    (`lam rA B) ‚Üí ‚ü® [ rA ]·∂ú `‚ä¢ B ‚ü© =‚áí rA ‚ä∏ B
    (`app rA@(r , A) B) ‚Üí ‚ü® []·∂ú `‚ä¢ rA ‚ä∏ B ‚ü© `‚ú¥ r `¬∑ ‚ü® []·∂ú `‚ä¢ A ‚ü© =‚áí B

  Term = [ AnnArr , ‚àû ]_‚ä¢_
  open WithScope (Scope Term)

  -- pattern var i les = `var (lvar i refl les)
  -- pattern lam t = `con (`lam _ _ , refl , t)

  ‚ü¶_‚üß : Ty ‚Üí Set
  ‚ü¶ base ‚üß = Base
  ‚ü¶ (_ , A) ‚ä∏ B ‚üß = ‚ü¶ A ‚üß ‚Üí ‚ü¶ B ‚üß

  ‚ü¶_‚üß·∂ú : Ctx ‚Üí Set
  ‚ü¶ ctx _ Œ≥ ‚üß·∂ú = Lift‚ÇÅ ‚ü¶_‚üß Œ≥

  ‚ü¶Tm‚üß : OpenFam 0‚Ñì
  ‚ü¶Tm‚üß Œì A = ‚ü¶ Œì ‚üß·∂ú ‚Üí ‚ü¶ A ‚üß

  open Semantics
  open With-psh^ùì• (Œª {s} {Œ≥} {P} {Q} ‚Üí psh^‚àã {s} {Œ≥} {P} {Q})

  set : Semantics AnnArr _‚àã_ ‚ü¶Tm‚üß
  set .ren^ùì• = ren^‚àã
  set .var (lvar i ‚â°.refl _) Œ≥0 = Œ≥0 .get i
  set .alg {ctx P Œ≥} (`lam (r , A) B , ‚â°.refl , m) Œ≥0 x =
    m .get {ctx P Œ≥ ++·∂ú [ 0# , A ]·∂ú} extend ≥
      .app‚ú¥ +*-triv ([-]·µâ (‚ü® *‚Çó-triv ‚ü©¬∑ lvar (‚Üò here) ‚â°.refl ‚â§*-refl))
      (Œ≥0 ++‚ÇÅ [ x ]‚ÇÅ)
  set .alg (`app rA B , ‚â°.refl , m ‚ú¥‚ü® sp+ ‚ü© (‚ü® sp* ‚ü©¬∑ n)) Œ≥0 =
    (m .get identity .app‚ú¥ (+*-identity‚Üò _) ([]·µâ ‚Ñë‚ü® 0*-triv ‚ü©) Œ≥0)
    (n .get identity .app‚ú¥ (+*-identity‚Üò _) ([]·µâ ‚Ñë‚ü® 0*-triv ‚ü©) Œ≥0)

  myConst : (A B : Ty) ‚Üí Term []·∂ú ((1# , A) ‚ä∏ (0# , B) ‚ä∏ A)
  myConst A B =
    `con (`lam _ _ , ‚â°.refl , `con (`lam _ _ , ‚â°.refl ,
      `var (lvar (‚Üô (‚Üò here)) ‚â°.refl (([]‚Çô ++‚Çô [ ‚â§-refl ]‚Çô) ++‚Çô ‚â§*-refl))))

  ‚ü¶myConst‚üß : (A B : Ty) ‚Üí ‚ü¶ A ‚üß ‚Üí ‚ü¶ B ‚üß ‚Üí ‚ü¶ A ‚üß
  ‚ü¶myConst‚üß A B = semantics set {[]·∂ú} {[]·∂ú} ([]·µâ ‚Ñë‚ü® []‚Çô ‚ü©) (myConst A B) []‚ÇÅ

  test : (x y : Base) ‚Üí ‚ü¶myConst‚üß base base x y ‚â° x
  test x y = ‚â°.refl

  -- Setoid semantics

  ‚ü¶_‚üßÀ¢ : Ty ‚Üí Setoid 0‚Ñì 0‚Ñì
  ‚ü¶ base ‚üßÀ¢ = ‚â°.setoid Base  -- TODO: Base should be a Setoid.
  ‚ü¶ (_ , A) ‚ä∏ B ‚üßÀ¢ = ‚ü¶ A ‚üßÀ¢ ‚á® ‚ü¶ B ‚üßÀ¢

  ‚ü¶_‚üßÀ¢·∂ú : Ctx ‚Üí Setoid 0‚Ñì 0‚Ñì
  ‚ü¶ ctx _ Œ≥ ‚üßÀ¢·∂ú = setoidL‚ÇÅ ‚ü¶_‚üßÀ¢ Œ≥

  ‚ü¶Tm‚üßÀ¢ : OpenFam 0‚Ñì
  ‚ü¶Tm‚üßÀ¢ Œì A = ‚ü¶ Œì ‚üßÀ¢·∂ú ‚ü∂ ‚ü¶ A ‚üßÀ¢

  module _ where

    open Setoid

    setoid : Semantics AnnArr _‚àã_ ‚ü¶Tm‚üßÀ¢
    setoid .ren^ùì• = ren^‚àã
    setoid .var (lvar i ‚â°.refl _) ‚ü®$‚ü© Œ≥0 = Œ≥0 .get i
    setoid .var (lvar i ‚â°.refl _) .cong Œ≥Œ≥ = Œ≥Œ≥ .get i
    -- TODO: lam case could be made better by Setoid currying.
    setoid .alg {ctx P Œ≥} (`lam (r , A) B , ‚â°.refl , m) ‚ü®$‚ü© Œ≥0 ‚ü®$‚ü© x =
      m .get {ctx P Œ≥ ++·∂ú [ 0# , A ]·∂ú} extend ≥
        .app‚ú¥ +*-triv ([-]·µâ (‚ü® *‚Çó-triv ‚ü©¬∑ lvar (‚Üò here) ‚â°.refl ‚â§*-refl))
        ‚ü®$‚ü© (Œ≥0 ++‚ÇÅ [ x ]‚ÇÅ)
    setoid .alg {ctx P Œ≥} (`lam (r , A) B , ‚â°.refl , m) ._‚ü®$‚ü©_ Œ≥0 .cong xx =
      m .get _ .app‚ú¥ _ _ .cong (setoidL‚ÇÅ ‚ü¶_‚üßÀ¢ _ .refl ++‚ÇÅ‚àº [ xx ]‚ÇÅ‚àº)
    setoid .alg (`lam rA B , ‚â°.refl , m) .cong Œ≥Œ≥ xx =
      m .get _ .app‚ú¥ _ _ .cong (Œ≥Œ≥ ++‚ÇÅ‚àº [ xx ]‚ÇÅ‚àº)
    setoid .alg (`app rA B , ‚â°.refl , m ‚ú¥‚ü® sp+ ‚ü© (‚ü® sp* ‚ü©¬∑ n)) ‚ü®$‚ü© Œ≥0 =
      (m .get identity .app‚ú¥ (+*-identity‚Üò _) ([]·µâ ‚Ñë‚ü® 0*-triv ‚ü©) ‚ü®$‚ü© Œ≥0) ‚ü®$‚ü©
      (n .get identity .app‚ú¥ (+*-identity‚Üò _) ([]·µâ ‚Ñë‚ü® 0*-triv ‚ü©) ‚ü®$‚ü© Œ≥0)
    setoid .alg (`app rA B , ‚â°.refl , m ‚ú¥‚ü® sp+ ‚ü© (‚ü® sp* ‚ü©¬∑ n)) .cong Œ≥Œ≥ =
      m .get _ .app‚ú¥ _ _ .cong Œ≥Œ≥ (n .get _ .app‚ú¥ _ _ .cong Œ≥Œ≥)

  -- Relational semantics

  record WRel {W : Set} (_‚â§_ : Rel W 0‚Ñì) (A : Setoid 0‚Ñì 0‚Ñì) : Set‚ÇÅ where
    private module A = Setoid A
    field
      rel : (a b : A.Carrier) ‚Üí W ‚Üí Set
      resp-‚âà : ‚àÄ {a a‚Ä≤ b b‚Ä≤} ‚Üí a A.‚âà a‚Ä≤ ‚Üí b A.‚âà b‚Ä≤ ‚Üí ‚àÄ[ rel a b ‚áí rel a‚Ä≤ b‚Ä≤ ]
      subres : ‚àÄ {a b w w‚Ä≤} ‚Üí w‚Ä≤ ‚â§ w ‚Üí rel a b w ‚Üí rel a b w‚Ä≤
  open WRel public

  -- TODO: move somewhere else (Relation.Unary.Extras?)

  I‚ãÇ : ‚àÄ {a i ‚Ñì} {A : Set a} (I : Set i) ‚Üí (I ‚Üí Pred A ‚Ñì) ‚Üí Pred A _
  I‚ãÇ I P = Œª x ‚Üí {i : I} ‚Üí P i x

  record WRelMor {W ‚â§ ∑ A B} (R : WRel {W} ‚â§ ∑ A) (S : WRel ‚â§ ∑ B) : Set where
    constructor wRelMor
    private
      module A = Setoid A
      module B = Setoid B
    field
      sem0 sem1 : A ‚ü∂ B
      semsem : ‚àÄ[ (I‚ãÇ (_ √ó _) \ (x , y) ‚Üí
                   R .rel x y ‚áí S .rel (sem0 ‚ü®$‚ü© x) (sem1 ‚ü®$‚ü© y)) ]
  open WRelMor public

  module WithWorlds
    (worlds : CommutativeRelMonoid 0‚Ñì 0‚Ñì)
    (open CommutativeRelMonoid worlds renaming
      (Carrier to W; _‚â§_ to _‚â§ ∑_; refl to ‚â§ ∑-refl))
    (open BunchedUnit _‚â§Œµ hiding (‚Ñë‚ü®_‚ü©))
    (open BunchedConjunction _‚â§[_‚àô_])
    where

    I·¥ø : WRel _‚â§ ∑_ (‚ä§.setoid ‚ä§ 0‚Ñì)
    I·¥ø .rel _ _ = ‚Ñë
    I·¥ø .resp-‚âà _ _ = id
    I·¥ø .subres sub ‚Ñë‚ü® sp ‚ü© = ‚Ñë‚ü® Œµ-mono sub sp ‚ü©

    _‚äó·¥ø_ : ‚àÄ {A B} ‚Üí WRel _‚â§ ∑_ A ‚Üí WRel _‚â§ ∑_ B ‚Üí WRel _‚â§ ∑_ (√ó-setoid A B)
    (R ‚äó·¥ø S) .rel (xa , xb) (ya , yb) = R .rel xa ya ‚ú¥ S .rel xb yb
    (R ‚äó·¥ø S) .resp-‚âà (xxa , xxb) (yya , yyb) =
      map-‚ú¥ (R .resp-‚âà xxa yya , S .resp-‚âà xxb yyb)
    (R ‚äó·¥ø S) .subres sub (r ‚ú¥‚ü® sp ‚ü© s) = r ‚ú¥‚ü® ‚àô-mono sub ‚â§ ∑-refl ‚â§ ∑-refl sp ‚ü© s

  module WithStuff
    (worlds : CommutativeRelMonoid 0‚Ñì 0‚Ñì)
    (open CommutativeRelMonoid worlds renaming
      (Carrier to W; _‚â§_ to _‚â§ ∑_; refl to ‚â§ ∑-refl; trans to ‚â§ ∑-trans))
    (open BunchedOrder _‚â§ ∑_)
    (open BunchedUnit _‚â§Œµ hiding (‚Ñë‚ü®_‚ü©))
    (open BunchedConjunction _‚â§[_‚àô_])
    (open WithWorlds worlds)
    (Base·¥ø : WRel _‚â§ ∑_ (‚â°.setoid Base))
    (!·¥ø : Ann ‚Üí ‚àÄ[ WRel _‚â§ ∑_ ‚áí WRel _‚â§ ∑_ ])
    (!·¥ø-‚â§ ∑ : ‚àÄ {r A R x y w w‚Ä≤} ‚Üí w‚Ä≤ ‚â§ ∑ w ‚Üí
      !·¥ø r {A} R .rel x y w ‚Üí !·¥ø r {A} R .rel x y w‚Ä≤)
    (!·¥ø-map : ‚àÄ {r A B R S} (f : WRelMor R S) ‚Üí ‚àÄ {x y} ‚Üí
      ‚àÄ[ !·¥ø r {A} R .rel x y ‚áí
         !·¥ø r {B} S .rel (f .sem0 ‚ü®$‚ü© x) (f .sem1 ‚ü®$‚ü© y) ])
    (!·¥ø-‚â§ : ‚àÄ {r s A R x y} ‚Üí r ‚â§ s ‚Üí
      ‚àÄ[ !·¥ø r {A} R .rel x y ‚áí !·¥ø s R .rel x y ])
    (!·¥ø-0 : ‚àÄ {r A R x y} ‚Üí r ‚â§ 0# ‚Üí ‚àÄ[ !·¥ø r {A} R .rel x y Chk.‚áí ‚Ñë ])
    (!·¥ø-+ : ‚àÄ {r p q A R x y} ‚Üí r ‚â§ p + q ‚Üí
      ‚àÄ[ !·¥ø r {A} R .rel x y ‚áí !·¥ø p R .rel x y ‚ú¥ !·¥ø q R .rel x y ])
    (!·¥ø-1 : ‚àÄ {r A R x y} ‚Üí r ‚â§ 1# ‚Üí ‚àÄ[ !·¥ø r {A} R .rel x y ‚áí R .rel x y ])
    (!·¥ø-* : ‚àÄ {r p q A R x y} ‚Üí r ‚â§ p * q ‚Üí
      ‚àÄ[ !·¥ø r {A} R .rel x y ‚áí !·¥ø p (!·¥ø q R) .rel x y ])
    (!·¥ø-‚Ñë : ‚àÄ {r x y} ‚Üí ‚àÄ[ ‚Ñë ‚áí !·¥ø r I·¥ø .rel x y ])
    (!·¥ø-‚ú¥ : ‚àÄ {r A B R S} {x@(xr , xs) : _ √ó _} {y@(yr , ys) : _ √ó _} ‚Üí
      ‚àÄ[ !·¥ø r {A} R .rel xr yr ‚ú¥ !·¥ø r {B} S .rel xs ys ‚áí
         !·¥ø r (R ‚äó·¥ø S) .rel x y ])
    where

    open BunchedCommutativeMonoid worlds

    ‚ü¶_‚üß·¥ø : ‚àÄ A ‚Üí WRel _‚â§ ∑_ ‚ü¶ A ‚üßÀ¢
    ‚ü¶ base ‚üß·¥ø = Base·¥ø
    ‚ü¶ (r , A) ‚ä∏ B ‚üß·¥ø .rel f g =
      I‚ãÇ (_ √ó _) \ (x , y) ‚Üí
        (!·¥ø r ‚ü¶ A ‚üß·¥ø .rel x y) ‚îÄ‚ú¥ ‚ü¶ B ‚üß·¥ø .rel (f ‚ü®$‚ü© x) (g ‚ü®$‚ü© y)
    ‚ü¶ (r , A) ‚ä∏ B ‚üß·¥ø .resp-‚âà ff gg fg .app‚ú¥ sp aa =
      ‚ü¶ B ‚üß·¥ø .resp-‚âà (ff A.refl) (gg A.refl) (fg .app‚ú¥ sp aa)
      where module A = Setoid ‚ü¶ A ‚üßÀ¢
    ‚ü¶ (r , A) ‚ä∏ B ‚üß·¥ø .subres sub rf .app‚ú¥ sp aa =
      rf .app‚ú¥ (‚àô-mono ‚â§ ∑-refl sub ‚â§ ∑-refl sp) aa

    module ‚ü¶_‚üß·¥ø·∂ú where
      go : ‚àÄ {s} R Œ≥ ‚Üí WRel _‚â§ ∑_ ‚ü¶ ctx {s} R Œ≥ ‚üßÀ¢·∂ú

      go {[-]} R Œ≥ .rel (mk Œ≥0) (mk Œ≥1) =
        !·¥ø (R here) ‚ü¶ Œ≥ here ‚üß·¥ø .rel (Œ≥0 here) (Œ≥1 here)
      go {[-]} R Œ≥ .resp-‚âà (mk p0) (mk p1) =
        !·¥ø (R here) ‚ü¶ Œ≥ here ‚üß·¥ø .resp-‚âà (p0 here) (p1 here)
      go {[-]} R Œ≥ .subres sub r = !·¥ø-‚â§ ∑ sub r

      go {Œµ} R Œ≥ .rel Œ≥0 Œ≥1 = ‚Ñë
      go {Œµ} R Œ≥ .resp-‚âà p0 p1 = id
      go {Œµ} R Œ≥ .subres sub ‚Ñë‚ü® sp ‚ü© = ‚Ñë‚ü® Œµ-mono sub sp ‚ü©

      go {s <+> t} R Œ≥ .rel (mk Œ≥0) (mk Œ≥1) =
        go (R ‚àò ‚Üô) (Œ≥ ‚àò ‚Üô) .rel (mk (Œ≥0 ‚àò ‚Üô)) (mk (Œ≥1 ‚àò ‚Üô)) ‚ú¥
        go (R ‚àò ‚Üò) (Œ≥ ‚àò ‚Üò) .rel (mk (Œ≥0 ‚àò ‚Üò)) (mk (Œ≥1 ‚àò ‚Üò))
      go {s <+> t} R Œ≥ .resp-‚âà (mk p0) (mk p1) = map-‚ú¥
        ( go (R ‚àò ‚Üô) (Œ≥ ‚àò ‚Üô) .resp-‚âà (mk (p0 ‚àò ‚Üô)) (mk (p1 ‚àò ‚Üô))
        , go (R ‚àò ‚Üò) (Œ≥ ‚àò ‚Üò) .resp-‚âà (mk (p0 ‚àò ‚Üò)) (mk (p1 ‚àò ‚Üò))
        )
      go {s <+> t} R Œ≥ .subres sub (rl ‚ú¥‚ü® sp ‚ü© rr) =
        rl ‚ú¥‚ü® ‚àô-mono sub ‚â§ ∑-refl ‚â§ ∑-refl sp ‚ü© rr

    ‚ü¶_‚üß·¥ø·∂ú : ‚àÄ RŒ≥ ‚Üí WRel _‚â§ ∑_ ‚ü¶ RŒ≥ ‚üßÀ¢·∂ú
    ‚ü¶ ctx R Œ≥ ‚üß·¥ø·∂ú = ‚ü¶_‚üß·¥ø·∂ú.go R Œ≥

    ‚ü¶‚â§‚üß·¥ø·∂ú : ‚àÄ {s P Q Œ≥} ‚Üí P ‚â§* Q ‚Üí
      ‚àÄ[ ‚ü¶ ctx {s} P Œ≥ ‚üß·¥ø·∂ú .rel ‚áí ‚ü¶ ctx Q Œ≥ ‚üß·¥ø·∂ú .rel ]
    ‚ü¶‚â§‚üß·¥ø·∂ú {[-]} (mk le) = !·¥ø-‚â§ (le here)
    ‚ü¶‚â§‚üß·¥ø·∂ú {Œµ} le = id
    ‚ü¶‚â§‚üß·¥ø·∂ú {s <+> t} (mk le) =
      map-‚ú¥ (‚ü¶‚â§‚üß·¥ø·∂ú (mk (le ‚àò ‚Üô)) , ‚ü¶‚â§‚üß·¥ø·∂ú (mk (le ‚àò ‚Üò)))

    {- Interesting, but unnecessary
    ‚ü¶Tm‚üß·¥ø : (A : Ty) (RŒ≥ : Ctx) ‚Üí WRel _‚â§ ∑_ (‚ü¶ RŒ≥ ‚üßÀ¢·∂ú ‚á® ‚ü¶ A ‚üßÀ¢)
    ‚ü¶Tm‚üß·¥ø A RŒ≥ .rel m0 m1 = I‚ãÇ (_ √ó _) \ (Œ≥0 , Œ≥1) ‚Üí
      ‚ü¶ RŒ≥ ‚üß·¥ø·∂ú .rel Œ≥0 Œ≥1 ‚áí·µè ‚ü¶ A ‚üß·¥ø .rel (m0 ‚ü®$‚ü© Œ≥0) (m1 ‚ü®$‚ü© Œ≥1)
    ‚ü¶Tm‚üß·¥ø A RŒ≥ .resp-‚âà p0 p1 mm le Œ≥Œ≥ =
      ‚ü¶ A ‚üß·¥ø .resp-‚âà (p0 RŒ≥.refl) (p1 RŒ≥.refl) (mm le Œ≥Œ≥)
      where module RŒ≥ = Setoid ‚ü¶ RŒ≥ ‚üßÀ¢·∂ú
    ‚ü¶Tm‚üß·¥ø A RŒ≥ .subres sub mm le Œ≥Œ≥ = mm (‚â§-trans le sub) Œ≥Œ≥
    -}

    ‚ü¶Tm‚üß-rel : (A : Ty) (RŒ≥ : Ctx) (m0 m1 : ‚ü¶ RŒ≥ ‚üßÀ¢·∂ú ‚ü∂ ‚ü¶ A ‚üßÀ¢) ‚Üí W ‚Üí Set
    ‚ü¶Tm‚üß-rel A RŒ≥ m0 m1 = I‚ãÇ (_ √ó _) \ (Œ≥0 , Œ≥1) ‚Üí
      ‚ü¶ RŒ≥ ‚üß·¥ø·∂ú .rel Œ≥0 Œ≥1 ‚áí ‚ü¶ A ‚üß·¥ø .rel (m0 ‚ü®$‚ü© Œ≥0) (m1 ‚ü®$‚ü© Œ≥1)

    lemma-‚Ñë : ‚àÄ {s R Œ≥ Œ≥0 Œ≥1} ‚Üí R ‚â§0* ‚Üí
      ‚àÄ[ ‚ü¶ ctx {s} R Œ≥ ‚üß·¥ø·∂ú .rel Œ≥0 Œ≥1 Chk.‚áí ‚Ñë ]
    lemma-‚Ñë {[-]} (mk sp) = !·¥ø-0 (sp here)
    lemma-‚Ñë {Œµ} sp = id
    lemma-‚Ñë {s <+> t} (mk sp) =
      1‚ú¥1‚Üí ‚àò map-‚ú¥ (lemma-‚Ñë (mk (sp ‚àò ‚Üô)) , lemma-‚Ñë (mk (sp ‚àò ‚Üò)))

    lemma-‚ú¥ : ‚àÄ {s R P Q Œ≥ Œ≥0 Œ≥1} ‚Üí R ‚â§[ P +* Q ] ‚Üí
      ‚àÄ[ ‚ü¶ ctx {s} R Œ≥ ‚üß·¥ø·∂ú .rel Œ≥0 Œ≥1 ‚áí
         ‚ü¶ ctx P Œ≥ ‚üß·¥ø·∂ú .rel Œ≥0 Œ≥1 ‚ú¥ ‚ü¶ ctx Q Œ≥ ‚üß·¥ø·∂ú .rel Œ≥0 Œ≥1 ]
    lemma-‚ú¥ {[-]} (mk sp) = !·¥ø-+ (sp here)
    lemma-‚ú¥ {Œµ} sp = 1‚ú¥1‚Üê
    lemma-‚ú¥ {s <+> t} (mk sp) =
      inter-‚ú¥ ‚àò map-‚ú¥ (lemma-‚ú¥ (mk (sp ‚àò ‚Üô)) , lemma-‚ú¥ (mk (sp ‚àò ‚Üò)))

    lemma-!·¥ø : ‚àÄ {s R r Q Œ≥ Œ≥0 Œ≥1} ‚Üí R ‚â§[ r *‚Çó Q ] ‚Üí
      ‚àÄ[ ‚ü¶ ctx {s} R Œ≥ ‚üß·¥ø·∂ú .rel Œ≥0 Œ≥1 ‚áí !·¥ø r ‚ü¶ ctx Q Œ≥ ‚üß·¥ø·∂ú .rel Œ≥0 Œ≥1 ]
    lemma-!·¥ø {[-]} {Q = Q} {Œ≥} (mk sp) =
      !·¥ø _ ‚ü¶ ctx Q Œ≥ ‚üß·¥ø·∂ú .resp-‚âà ([-]‚ÇÅŒ∑ (Œª {A} ‚Üí ‚ü¶_‚üßÀ¢.refl A))
                                 ([-]‚ÇÅŒ∑ (Œª {A} ‚Üí ‚ü¶_‚üßÀ¢.refl A))
      ‚àò‚Ä≤ !·¥ø-map f
      ‚àò‚Ä≤ !·¥ø-* (sp here)
      where
      module ‚ü¶_‚üßÀ¢ A = Setoid ‚ü¶ A ‚üßÀ¢

      f : WRelMor (!·¥ø (Q here) ‚ü¶ Œ≥ here ‚üß·¥ø) ‚ü¶ ctx Q Œ≥ ‚üß·¥ø·∂ú
      f .sem0 = [-]‚ÇÅÀ¢ {S = ‚ü¶_‚üßÀ¢}
      f .sem1 = [-]‚ÇÅÀ¢ {S = ‚ü¶_‚üßÀ¢}
      f .semsem = id
    lemma-!·¥ø {Œµ} {Q = Q} {Œ≥} sp = !·¥ø-map f ‚àò !·¥ø-‚Ñë
      where
      module QŒ≥ = Setoid ‚ü¶ ctx Q Œ≥ ‚üßÀ¢·∂ú

      f : WRelMor I·¥ø ‚ü¶ ctx Q Œ≥ ‚üß·¥ø·∂ú
      f .sem0 = record { cong = Œª _ ‚Üí QŒ≥.refl }
      f .sem1 = record { cong = Œª _ ‚Üí QŒ≥.refl }
      f .semsem = id
    lemma-!·¥ø {s <+> t} {Q = Q} {Œ≥} (mk sp) =
      !·¥ø _ ‚ü¶ ctx Q Œ≥ ‚üß·¥ø·∂ú .resp-‚âà (++‚ÇÅŒ∑ (Œª {A} ‚Üí ‚ü¶_‚üßÀ¢.refl A))
                                 (++‚ÇÅŒ∑ (Œª {A} ‚Üí ‚ü¶_‚üßÀ¢.refl A))
      ‚àò‚Ä≤ !·¥ø-map f
      ‚àò‚Ä≤ !·¥ø-‚ú¥
      ‚àò‚Ä≤ map-‚ú¥ (lemma-!·¥ø (mk (sp ‚àò ‚Üô)) , lemma-!·¥ø (mk (sp ‚àò ‚Üò)))
      where
      open module ‚ü¶_‚üßÀ¢ A = Setoid ‚ü¶ A ‚üßÀ¢

      f : WRelMor (‚ü¶ _ ‚üß·¥ø·∂ú ‚äó·¥ø ‚ü¶ _ ‚üß·¥ø·∂ú) ‚ü¶ ctx Q Œ≥ ‚üß·¥ø·∂ú
      f .sem0 = ++‚ÇÅÀ¢ {S = ‚ü¶_‚üßÀ¢}
      f .sem1 = ++‚ÇÅÀ¢ {S = ‚ü¶_‚üßÀ¢}
      f .semsem = id

    ‚óá-alg : ‚àÄ {A} (R : WRel _‚â§ ∑_ A) {x y} ‚Üí ‚àÄ[ ‚óá (R .rel x y) ‚áí R .rel x y ]
    ‚óá-alg R (‚óá‚ü® sub ‚ü© xy) = R .subres sub xy

    ‚ü¶Tm‚üß·¥ø : OpenFam 0‚Ñì
    ‚ü¶Tm‚üß·¥ø RŒ≥ A = WRelMor ‚ü¶ RŒ≥ ‚üß·¥ø·∂ú ‚ü¶ A ‚üß·¥ø

    wrel : Semantics AnnArr _‚àã_ ‚ü¶Tm‚üß·¥ø
    wrel .ren^ùì• = ren^‚àã
    wrel .var v .sem0 = setoid .var v
    wrel .var v .sem1 = setoid .var v
    wrel .var v .semsem = go v
      where
      -- Œ∑-expand RŒ≥ to satisfy termination checker (s gets smaller).
      go : ‚àÄ {A s R Œ≥} (let RŒ≥ = ctx {s} R Œ≥) (v : RŒ≥ ‚àã A) ‚Üí
           ‚àÄ[ ‚ü¶Tm‚üß-rel A RŒ≥ (setoid .var v) (setoid .var v) ]
      go (lvar here ‚â°.refl (mk le)) = !·¥ø-1 (le here)
      go {Œ≥ = Œ≥} (lvar (‚Üô i) ‚â°.refl (mk le)) = ‚óá-alg ‚ü¶ Œ≥ (‚Üô i) ‚üß·¥ø ‚àò‚Ä≤ ‚ú¥-1‚Üí ‚àò‚Ä≤
        map-‚ú¥ (go (lvar i ‚â°.refl (mk (le ‚àò ‚Üô))) , lemma-‚Ñë (mk (le ‚àò ‚Üò)))
      go {Œ≥ = Œ≥} (lvar (‚Üò i) ‚â°.refl (mk le)) = ‚óá-alg ‚ü¶ Œ≥ (‚Üò i) ‚üß·¥ø ‚àò‚Ä≤ 1-‚ú¥‚Üí ‚àò‚Ä≤
        map-‚ú¥ (lemma-‚Ñë (mk (le ‚àò ‚Üô)) , go (lvar i ‚â°.refl (mk (le ‚àò ‚Üò))))
    wrel .alg mm .sem0 = setoid .alg (map-s‚Ä≤ AnnArr (mapKùìí sem0) mm)
    wrel .alg mm .sem1 = setoid .alg (map-s‚Ä≤ AnnArr (mapKùìí sem1) mm)
    wrel .alg {ctx R Œ≥} (`lam (r , A) B , ‚â°.refl , mm)
      .semsem Œ≥Œ≥ .app‚ú¥ sp xx =
      mm .get _ .app‚ú¥ _ _ .semsem
        (‚ü¶‚â§‚üß·¥ø·∂ú {P = R} (mk (Œª i ‚Üí ‚â§-trans (+.identity-‚Üí .proj‚ÇÇ _)
                                          (+-mono ‚â§-refl (‚â§-annihil .proj‚ÇÇ _))))
               Œ≥Œ≥
         ‚ú¥‚ü® sp ‚ü©
         !·¥ø-‚â§ (‚â§-trans (*.identity .proj‚ÇÇ _) (+.identity-‚Üê .proj‚ÇÅ _)) xx)
    wrel .alg (`app rA B , ‚â°.refl , mm ‚ú¥‚ü® sp+ ‚ü© (‚ü® sp* ‚ü©¬∑ nn)) .semsem Œ≥Œ≥ =
      let Œ≥Œ≥ ‚ú¥‚ü® ‚ü¶sp+‚üß ‚ü© rQŒ≥Œ≥ = lemma-‚ú¥ sp+ Œ≥Œ≥ in
      mm .get _ .app‚ú¥ _ _ .semsem Œ≥Œ≥ .app‚ú¥ ‚ü¶sp+‚üß
        (!·¥ø-map
          (nn .get _ .app‚ú¥ (mk Œª i ‚Üí +.identity-‚Üí .proj‚ÇÇ _) ([]·µâ ‚Ñë‚ü® 0*-triv ‚ü©))
          (lemma-!·¥ø sp* rQŒ≥Œ≥))
