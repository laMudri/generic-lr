\begin{code}
{-# OPTIONS --sized-types --without-K --postfix-projections --prop #-}
module Generic.Linear.Example.PaperExamples where

open import Algebra.Po
open import Algebra.Po.Construct.Nat
open import Data.Hand
open import Data.LTree
open import Data.LTree.Vector
open import Data.Product
open import Data.Unit using (⊤; tt)
open import Level
open import Relation.Binary.PropositionalEquality as ≡ using (_≡_)
open import Relation.Unary.Bunched
open import Size

module CPP0 (poSemiring : PoSemiring 0ℓ 0ℓ 0ℓ) where

  open PoSemiring poSemiring using () renaming (Carrier to Ann) public

  infixr 5 _⊸_
  infix 6 _⊕_
\end{code}

%<*Ty>
\begin{code}
  data Ty : Set where
    ι : Ty
    _⊸_ _⊕_ : (A B : Ty) → Ty
    ! : (r : Ann) (A : Ty) → Ty
\end{code}
%</Ty>

\begin{code}
  open import Generic.Linear.Everything Ty poSemiring hiding (Ann) public
\end{code}

%<*qlR>
\begin{code}
  data `λR : Set where
    `⊸I `⊸E : (A B : Ty) → `λR
    `⊕I : (i : Hand) (A B : Ty) → `λR
    `⊕E : (A B C : Ty) → `λR
    `!I : (r : Ann) (A : Ty) → `λR
    `!E : (r : Ann) (A C : Ty) → `λR
\end{code}
%</qlR>

%<*lR>
\begin{code}
  λR : System
  λR = `λR ▹ λ where
    (`⊸I A B)     → ⟨ [ 1# ∙ A ]ᶜ `⊢ B ⟩                       `⊆ (A ⊸ B)
    (`⊸E A B)     → (⟨ []ᶜ `⊢ A ⊸ B ⟩ `✴ ⟨ []ᶜ `⊢ A ⟩)         `⊆ B
    (`!I r A)     → (r `· ⟨ []ᶜ `⊢ A ⟩)                        `⊆ (! r A)
    (`!E r A C)   → (⟨ []ᶜ `⊢ ! r A ⟩ `✴ ⟨ [ r ∙ A ]ᶜ `⊢ C ⟩)  `⊆ C
    (`⊕I ll A B)  → ⟨ []ᶜ `⊢ A ⟩                               `⊆ (A ⊕ B)
    (`⊕I rr A B)  → ⟨ []ᶜ `⊢ B ⟩                               `⊆ (A ⊕ B)
    (`⊕E A B C)   →
      ⟨ []ᶜ `⊢ A ⊕ B ⟩ `✴ (⟨ [ 1# ∙ A ]ᶜ `⊢ C ⟩ `∧ ⟨ [ 1# ∙ B ]ᶜ `⊢ C ⟩) `⊆ C
\end{code}
%</lR>

\begin{code}
  _ : Ann → Ty → Ty → Ty
  _ = λ r A B →
\end{code}
%<*BangrAToB>
\begin{code}[inline]
    (! r A) ⊸ B
\end{code}
%</BangrAToB>

\begin{code}
module CPP0Concrete where

  open import Generic.Linear.Example.ZeroOneMany
    renaming (0# to 0#; 1# to 1#; ω# to ω#)
  open CPP0 poSemiring

  open import Data.LTree.Automation
  open import Data.Nat using (ℕ)
  open import Data.Nat.Properties using (_<?_)
  open import Relation.Nullary.Decidable using (True)

  open import Generic.Linear.Example.UsageCheck Ty
  open WithPoSemiring poSemiring
  open WithInverses record
    { 0#⁻¹ = 0#⁻¹ ; +⁻¹ = +⁻¹ ; 1#⁻¹ = 1#⁻¹ ; *⁻¹ = *⁻¹ ; rep = rep }
\end{code}

%<*patterns>
\begin{code}
  pattern ⊸I M = U.`con (`⊸I _ _ , ≡.refl , M)
  pattern !I M = U.`con (`!I _ _ , ≡.refl , ⟨ _ ⟩·ᶜ M)
  pattern !E M N = U.`con (`!E _ _ _ , ≡.refl , M ✴ᶜ⟨ _ ⟩ N)
  pattern ⊕I i M = U.`con (`⊕I i _ _ , ≡.refl , M)
  pattern ⊕E M N O = U.`con (`⊕E _ _ _ , ≡.refl , M ✴ᶜ⟨ _ ⟩ (N , O))

  var# : ∀ {s} m {m< : True (m <? size s)} {d sz γ} →
    U.[ d , ↑ sz ] U.ctx {s} _ γ ⊢ γ (#_ m {m<})
  var# {s} m {m<} = U.`var (U.lvar (#_ {s} m {m<}) ≡.refl _)
\end{code}
%</patterns>

%<*cojoin>
\begin{code}
  cojoin-!ω : ∀ {A} → [ λR , ∞ ] []ᶜ ⊢ (! ω# A ⊸ ! ω# (! ω# A))
  cojoin-!ω = elab-unique _ (⊸I (!E (var# 0) (!I (!I (var# 1))))) []
\end{code}
%</cojoin>

\begin{code}
  foo : ∀ {A B} → [ λR , ∞ ] []ᶜ ⊢ (! ω# A ⊕ ! ω# B ⊸ ! ω# (A ⊕ B))
  foo = elab-unique _
    (⊸I (⊕E (var# 0)  (!E (var# 1) (!I (⊕I ll (uvar #2))))
                      (!E (var# 1) (!I (⊕I rr (uvar #2)))))) []
    where
    #2 = ↙ (↙ (↘ here))
\end{code}

\begin{code}
module Example1 (poSemiring : PoSemiring 0ℓ 0ℓ 0ℓ) where

  open PoSemiring poSemiring
    renaming (Carrier to Ann
             ; _≤_ to _⊴_
             ; refl to ⊴-refl; trans to ⊴-trans
             )

  infixr 5 _·_⊸_
  infixr 6 _⊕_
\end{code}

%<*exItypes>
\begin{code}
  data Ty : Set where
    ι : Ty
    _·_⊸_ : (r : Ann) (A B : Ty) → Ty
    _⊕_ : (A B : Ty) → Ty
\end{code}
%</exItypes>

\begin{code}
  open import Generic.Linear.Syntax Ty Ann
  open import Generic.Linear.Syntax.Interpretation Ty rawPoSemiring
  open import Generic.Linear.Syntax.Term Ty rawPoSemiring
\end{code}

%<*exIlabels>
\begin{code}
  data `Sys : Set where
    `lam `app : (r : Ann) (A B : Ty) → `Sys
    `inl `inr : (A B : Ty) → `Sys
    `case : (A B C : Ty) → `Sys
\end{code}
%</exIlabels>

\begin{code}
  Sys : System
  Sys .Label = `Sys
\end{code}
%<*exIfunrules>
\begin{code}
  Sys .rules (`lam r A B) =
    ⟨ [ r , A ]ᶜ `⊢ B ⟩
    `⊆ r · A ⊸ B
  Sys .rules (`app r A B) =
    ⟨ []ᶜ `⊢ r · A ⊸ B ⟩ `✴ r `· ⟨ []ᶜ `⊢ A ⟩
    `⊆ B
\end{code}
%</exIfunrules>
%<*exIsumrules>
\begin{code}
  Sys .rules (`inl A B) =
    ⟨ []ᶜ `⊢ A ⟩
    `⊆ A ⊕ B
  Sys .rules (`inr A B) =
    ⟨ []ᶜ `⊢ B ⟩
    `⊆ A ⊕ B
  Sys .rules (`case A B C) =
    ⟨ []ᶜ `⊢ A ⊕ B ⟩ `✴ (⟨ [ 1# , A ]ᶜ `⊢ C ⟩ `∧ ⟨ [ 1# , B ]ᶜ `⊢ C ⟩)
    `⊆ C
\end{code}
%</exIsumrules>
