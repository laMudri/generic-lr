\begin{code}
{-# OPTIONS --safe --without-K #-}

open import Algebra.Po
open import Level using (Level; 0ℓ; _⊔_)
open import Relation.Binary using (Rel)

module Generic.Linear.Syntax.Interpretation
  (Ty : Set) (rawPoSemiring : RawPoSemiring 0ℓ 0ℓ 0ℓ)
  where

  open RawPoSemiring rawPoSemiring renaming (Carrier to Ann)

  open import Data.Bool.Base
  open import Data.Product as ×
  open import Data.Unit
  open import Data.Wrap
  open import Function
  open import Relation.Binary.PropositionalEquality using (_≡_)
  open import Relation.Unary.Checked

  open import Data.LTree
  open import Data.LTree.Vector

  open import Generic.Linear.Operations rawPoSemiring
  open import Generic.Linear.Syntax Ty Ann

  private
    variable
      ℓ t u : Level

  infix 4 _≤ᶜ_

  data _≤ᶜ_ (Γ : Ctx) : Ctx → Set where
    mkᶜ : ∀ {Q} → Γ .use-ctx ≤* Q → Γ ≤ᶜ ctx Q (Γ .ty-ctx)
  data _≤0ᶜ (Γ : Ctx) : Set where
    mkᶜ : Γ .use-ctx ≤0* → Γ ≤0ᶜ
  data _≤[_+ᶜ_] (Θ : Ctx) : (Γ Δ : Ctx) → Set where
    mkᶜ : ∀ {P Q} → Θ .use-ctx ≤[ P +* Q ] → Θ ≤[ ctx P (Θ .ty-ctx) +ᶜ ctx Q (Θ .ty-ctx) ]
  data _≤[_*ₗᶜ_] (Γ : Ctx) r : (Δ : Ctx) → Set where
    mkᶜ : ∀ {Q} → Γ .use-ctx ≤[ r *ₗ Q ] → Γ ≤[ r *ₗᶜ ctx Q (Γ .ty-ctx) ]

  open import Relation.Unary.Bunched.Checked as Chk
  open BunchedUnit _≤0ᶜ public
  open BunchedConjunction _≤[_+ᶜ_] using (_✴_; map-✴) public
  open BunchedScaling _≤[_*ₗᶜ_] public
  -- open BunchedDuplicable _≤ᶜ_ _≤0ᶜ _≤[_+ᶜ_] _≤[_*ₗᶜ_] public
  import Relation.Unary.Bunched as Syn
  open Syn.BunchedOrder _≤ᶜ_ public
  open Syn.BunchedConjunction _≤[_+ᶜ_] using (_─✴_; lam✴; app✴) public

  open module CtxDup {s} = Duplicable (_≤*_ {s}) _≤0* _≤[_+*_] _≤[_*ₗ_]
  data Dupᶜ (Γ : Ctx) : (Δ : Ctx) → Set where
    mkᶜ : ∀ {Q} → Dup (Γ .use-ctx) Q → Dupᶜ Γ (ctx Q (Γ .ty-ctx))

  open BunchedModal Dupᶜ public

  infixr 9 _✴ᶜ⟨_⟩_
  infixr 10 ⟨_⟩·ᶜ_
  infixr 10 □ᶜ⟨_⟩_

  pattern ℑᶜ⟨_⟩ sp = Chk.ℑ⟨ mkᶜ sp ⟩
  pattern _✴ᶜ⟨_⟩_ t sp u = t Chk.✴⟨ mkᶜ sp ⟩ u
  pattern ⟨_⟩·ᶜ_ sp t = Chk.⟨ mkᶜ sp ⟩· t
  pattern □ᶜ⟨_⟩_ r t = Chk.□⟨ mkᶜ r ⟩ t
\end{code}

%<*semp>
\begin{code}
  ⟦_⟧p : Premises → ExtOpenFam ℓ → OpenType ℓ
  ⟦ ⟨ Δ `⊢ A ⟩ ⟧p X Γ = X Δ Γ A
  ⟦ `⊤ ⟧p X = U;  ⟦ p `∧ q ⟧p X = ⟦ p ⟧p X ∩ ⟦ q ⟧p X
  ⟦ `ℑ ⟧p X = ℑ;  ⟦ p `✴ q ⟧p X = ⟦ p ⟧p X ✴ ⟦ q ⟧p X
  ⟦ r `· p ⟧p X = r · ⟦ p ⟧p X
\end{code}
%</semp>
\begin{code}
  ⟦ `□⁰⁺ˣ p ⟧p X = Box (⟦ p ⟧p X)
\end{code}

%<*semr>
\begin{code}
  ⟦_⟧r : Rule → ExtOpenFam ℓ → OpenFam ℓ
  ⟦ ps `⊆ A′ ⟧r X Γ A = A′ ≡ A × ⟦ ps ⟧p X Γ
\end{code}
%</semr>

%<*sems>
\begin{code}
  ⟦_⟧s : System → ExtOpenFam ℓ → OpenFam ℓ
  ⟦ L ▹ rs ⟧s X Γ A = Σ[ l ∈ L ] ⟦ rs l ⟧r X Γ A
\end{code}
%</sems>
