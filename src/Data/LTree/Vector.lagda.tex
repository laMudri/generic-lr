\begin{code}
{-# OPTIONS --safe --without-K --postfix-projections #-}

-- Functional vectors indexed by tree sizes

module Data.LTree.Vector where

  open import Data.LTree

  open import Algebra.Core using (Op₂)
  open import Data.Product using (_×_; proj₁; proj₂; _,_; uncurry)
  open import Data.Product.Relation.Binary.Pointwise.NonDependent as ×PW
    using (×-setoid)
  open import Data.Product.Nary.NonDependent hiding (Allₙ)
  open import Data.Unit using (⊤; tt)
  open import Function.Base using (id; _∘_; _$_; case_of_; case_return_of_; _∋_)
  open import Function.Equality using (_⟶_; _⟨$⟩_; cong)
  open import Function.Nary.NonDependent
  open import Level using (Level; _⊔_; 0ℓ)
  open import Relation.Binary
    using (REL; Rel; Setoid; IsEquivalence; Reflexive)
  open import Relation.Binary.Construct.Always as ⊤ using ()
  open import Relation.Unary using (Pred)

  private
    variable
      a b c r ℓ : Level
      A : Set a
      B : Set b
      C : Set c
      s t : LTree

  infix 5 _++_
\end{code}

%<*Vector>
\begin{code}
  Vector : Set a → LTree → Set a
  Vector A s = Ptr s → A
\end{code}
%</Vector>

\begin{code}
  lift₀ : A → ∀ {s} → Vector A s
  lift₀ x _ = x

  lift₁ : (A → B) → ∀ {s} → Vector A s → Vector B s
  lift₁ f u i = f (u i)

  lift₂ : (A → B → C) → ∀ {s} → Vector A s → Vector B s → Vector C s
  lift₂ f u v i = f (u i) (v i)

  open import Data.Nat.Base using (ℕ; zero; suc)
  open import Data.Fin.Base using (Fin; zero; suc)
  open import Relation.Binary.PropositionalEquality as ≡ using (_≡_; _≗_)

  -- TODO: contribute Product⊤ₙ stuff to stdlib

  {-
  tabulate⊤ₙ : ∀ n {ls} {as : Sets n ls} → (∀ k → Projₙ as k) → Product⊤ n as
  tabulate⊤ₙ zero f = _
  tabulate⊤ₙ (suc n) f = f zero , tabulate⊤ₙ n λ k → f (suc k)

  proj⊤ₙ : ∀ n {ls} {as : Sets n ls} k → Product⊤ n as → Projₙ as k
  proj⊤ₙ _ zero (x , xs) = x
  proj⊤ₙ _ (suc k) (x , xs) = proj⊤ₙ _ k xs
  -}

  map×⊤ₙ :
    ∀ {f g} {F : ∀ {l} → Set l → Set (f l)} {G : ∀ {l} → Set l → Set (g l)} →
    (∀ {a} {A : Set a} → F A → G A) →
    ∀ n {as} {As : Sets n as} →
    (Product⊤ n (smap f F n As) → Product⊤ n (smap g G n As))
  map×⊤ₙ h zero tt = tt
  map×⊤ₙ h (suc n) (x , xs) = h x , map×⊤ₙ h n xs

  map×⊤ₙ← : ∀ {f} {F : ∀ {l} → Set l → Set (f l)} →
    (∀ {a} {A : Set a} → F A → A) →
    ∀ n {as} {As : Sets n as} → (Product⊤ n (smap f F n As) → Product⊤ n As)
  map×⊤ₙ← g zero tt = tt
  map×⊤ₙ← g (suc n) (x , xs) = g x , map×⊤ₙ← g n xs

  map×⊤ₙ→ : ∀ {f} {F : ∀ {l} → Set l → Set (f l)} →
    (∀ {a} {A : Set a} → A → F A) →
    ∀ n {as} {As : Sets n as} → (Product⊤ n As → Product⊤ n (smap f F n As))
  map×⊤ₙ→ g zero tt = tt
  map×⊤ₙ→ g (suc n) (x , xs) = g x , map×⊤ₙ→ g n xs

  map×⊤ₙ←∘map×⊤ₙ-→ : ∀ n {as} {As : Sets n as} {f g : Level → Level}
    {F : ∀ {l} → Set l → Set (f l)} {G : ∀ {l} → Set l → Set (g l)}
    {p} (P : Product⊤ n As → Set p)
    (i : ∀ {a} {A : Set a} → F A → A) (j : ∀ {a} {A : Set a} → G A → F A)
    (xs : Product⊤ n (smap g G n As)) →
    P (map×⊤ₙ← i n (map×⊤ₙ j n xs)) → P (map×⊤ₙ← (i ∘ j) n xs)
  map×⊤ₙ←∘map×⊤ₙ-→ zero P i j tt p = p
  map×⊤ₙ←∘map×⊤ₙ-→ (suc n) P i j (x , xs) p =
    map×⊤ₙ←∘map×⊤ₙ-→ n (λ xs → P (i (j x) , xs)) i j xs p

  map×⊤ₙ←∘map×⊤ₙ-← : ∀ n {as} {As : Sets n as} {f g : Level → Level}
    {F : ∀ {l} → Set l → Set (f l)} {G : ∀ {l} → Set l → Set (g l)}
    {p} (P : Product⊤ n As → Set p)
    {i : ∀ {a} {A : Set a} → F A → A} {j : ∀ {a} {A : Set a} → G A → F A}
    {xs : Product⊤ n (smap g G n As)} →
    P (map×⊤ₙ← (i ∘ j) n xs) → P (map×⊤ₙ← i n (map×⊤ₙ j n xs))
  map×⊤ₙ←∘map×⊤ₙ-← zero P {xs = tt} p = p
  map×⊤ₙ←∘map×⊤ₙ-← (suc n) P {i} {j} {xs = x , xs} p =
    map×⊤ₙ←∘map×⊤ₙ-← n (λ xs → P (i (j x) , xs)) {xs = xs} p

  const×⊤ₙ :
    ∀ {f} {F : ∀ {a} → Set a → Set (f a)} → (∀ {a} {A : Set a} → F A) →
    ∀ {n as} {As : Sets n as} → Product⊤ n (smap f F n As)
  const×⊤ₙ x {zero} = tt
  const×⊤ₙ x {suc n} = x , const×⊤ₙ x {n}

  zipWith×⊤ₙ :
    ∀ {f g h} {F : ∀ {l} → Set l → Set (f l)} {G : ∀ {l} → Set l → Set (g l)}
    {H : ∀ {l} → Set l → Set (h l)} → (∀ {a} {A : Set a} → F A → G A → H A) →
    ∀ {n as} {As : Sets n as} →
    Product⊤ n (smap f F n As) → Product⊤ n (smap g G n As) →
    Product⊤ n (smap h H n As)
  zipWith×⊤ₙ c {zero} tt tt = tt
  zipWith×⊤ₙ c {suc n} (x , xs) (y , ys) = c x y , zipWith×⊤ₙ c {n} xs ys

  -- map×⊤ₙ←∘zipWith×⊤ₙ-← : ∀ n {as} {As : Sets n as} {f g h : Level → Level}
  --   {F : ∀ {l} → Set l → Set (f l)} {G : ∀ {l} → Set l → Set (g l)}
  --   {H : ∀ {l} → Set l → Set (h l)}
  --   {p} (P : Product⊤ n As → Set p)
  --   (i : ∀ {a} {A : Set a} → F A → A) (j : ∀ {a} {A : Set a} → G A → H A → F A)
  --   (xs : Product⊤ n (smap g G n As)) (ys : Product⊤ n (smap h H n As)) →
  --   P (zipWith×⊤ₙ (λ x y → i (j x y)) xs ys) → P (map×⊤ₙ← i n (zipWith×⊤ₙ j xs ys))
  -- map×⊤ₙ←∘zipWith×⊤ₙ-← n P i j xs p = ?
  -- map×⊤ₙ←∘map×⊤ₙ-← zero P i j tt p = p
  -- map×⊤ₙ←∘map×⊤ₙ-← (suc n) P i j (x , xs) p =
  --   map×⊤ₙ←∘map×⊤ₙ-← n (λ xs → P (i (j x) , xs)) i j xs p

  record Allₙ′ {n as r} {As : Sets n as} (R : As ⇉ Set r)
    {s} (vs : Product⊤ n (smap id (λ A → Vector A s) n As)) : Set r where
    constructor mk
    field get : ∀ (i : Ptr s) → uncurry⊤ₙ n R (map×⊤ₙ← (_$ i) n vs)
  open Allₙ′ public

  Allₙ : ∀ {n as r} {As : Sets n as} (R : As ⇉ Set r) {s} →
    smap id (λ A → Vector A s) n As ⇉ Set r
  Allₙ {n} R = curry⊤ₙ n (Allₙ′ R)

  [_] : A → Vector A [-]
  [ x ] _ = x

  [] : Vector A ε
  [] ()

  _++_ : Vector A s → Vector A t → Vector A (s <+> t)
  (u ++ v) (↙ i) = u i
  (u ++ v) (↘ j) = v j

  un[-] : Vector A [-] → A
  un[-] v = v here

  un++ : Vector A (s <+> t) → Vector A s × Vector A t
  un++ v = v ∘ ↙ , v ∘ ↘

  module _ {n as r} {As : Sets n as} {R : As ⇉ Set r} where

    infix 5 _++ₙ_ _++ₙ⁺_

    [_]ₙ : {vs : Product⊤ n (smap id (λ A → Vector A [-]) n As)} →
      uncurry⊤ₙ n R (map×⊤ₙ← (_$ here) n vs) → Allₙ′ R vs
    [ r ]ₙ .get here = r

    []ₙ : {vs : Product⊤ n (smap id (λ A → Vector A ε) n As)} → Allₙ′ R vs
    []ₙ .get ()

    _++ₙ_ :
      ∀ {s t} {vs : Product⊤ n (smap id (λ A → Vector A (s <+> t)) n As)} →
      Allₙ′ R (map×⊤ₙ (_∘ ↙) n vs) → Allₙ′ R (map×⊤ₙ (_∘ ↘) n vs) →
      Allₙ′ R vs
    (ru ++ₙ rv) .get (↙ i) =
      map×⊤ₙ←∘map×⊤ₙ-→ n (uncurry⊤ₙ n R) _ _ _ (ru .get i)
    (ru ++ₙ rv) .get (↘ i) =
      map×⊤ₙ←∘map×⊤ₙ-→ n (uncurry⊤ₙ n R) _ _ _ (rv .get i)

    -- The ⁺-variants synthesise the shape of the vectors they relate.

    [_]ₙ⁺ : {xs : Product⊤ n As} →
      uncurry⊤ₙ n R xs → Allₙ′ R (map×⊤ₙ→ [_] n xs)
    [ rx ]ₙ⁺ = [ lemma R rx ]ₙ
      where
      lemma : ∀ {n as} {As : Sets n as} (R : As ⇉ Set r) {xs : Product⊤ n As} →
        uncurry⊤ₙ n R xs →
        uncurry⊤ₙ n R (map×⊤ₙ← (_$ here) n (map×⊤ₙ→ [_] n xs))
      lemma {zero} R r = r
      lemma {suc n} R r = lemma {n} (R _) r

    []ₙ⁺ : Allₙ′ R (const×⊤ₙ [])
    []ₙ⁺ = []ₙ

    _++ₙ⁺_ :
      ∀ {s t} {us : Product⊤ n (smap id (λ A → Vector A s) n As)}
      {vs : Product⊤ n (smap id (λ A → Vector A t) n As)} →
      Allₙ′ R us → Allₙ′ R vs →
      Allₙ′ R (zipWith×⊤ₙ _++_ us vs)
    _++ₙ⁺_ {s} {t} ru rv =
      (mk λ i → map×⊤ₙ←∘map×⊤ₙ-← n (uncurry⊤ₙ n R) (lemma-u R (ru .get i)))
        ++ₙ
      (mk λ i → map×⊤ₙ←∘map×⊤ₙ-← n (uncurry⊤ₙ n R) (lemma-v R (rv .get i)))
      where
      lemma-u : ∀ {n as} {As : Sets n as} (R : As ⇉ Set r)
        {us : Product⊤ n (smap id (λ A → Vector A s) n As)}
        {vs : Product⊤ n (smap id (λ A → Vector A t) n As)} {i} →
        uncurry⊤ₙ n R (map×⊤ₙ← (_$ i) n us) →
        uncurry⊤ₙ n R (map×⊤ₙ← (_$ ↙ i) n (zipWith×⊤ₙ _++_ us vs))
      lemma-u {zero} R r = r
      lemma-u {suc n} R r = lemma-u {n} (R _) r

      lemma-v : ∀ {n as} {As : Sets n as} (R : As ⇉ Set r)
        {us : Product⊤ n (smap id (λ A → Vector A s) n As)}
        {vs : Product⊤ n (smap id (λ A → Vector A t) n As)} {i} →
        uncurry⊤ₙ n R (map×⊤ₙ← (_$ i) n vs) →
        uncurry⊤ₙ n R (map×⊤ₙ← (_$ ↘ i) n (zipWith×⊤ₙ _++_ us vs))
      lemma-v {zero} R r = r
      lemma-v {suc n} R r = lemma-v {n} (R _) r

    -- We have a kind of pattern-matching for Allₙ inhabitants.

    un[-]ₙ : {vs : Product⊤ n (smap id (λ A → Vector A [-]) n As)} →
      Allₙ′ R vs → uncurry⊤ₙ n R (map×⊤ₙ← (_$ here) n vs)
    un[-]ₙ r = r .get here

    un++ₙ :
      ∀ {s t} {vs : Product⊤ n (smap id (λ A → Vector A (s <+> t)) n As)} →
      Allₙ′ R vs →
      Allₙ′ R (map×⊤ₙ (_∘ ↙) n vs) × Allₙ′ R (map×⊤ₙ (_∘ ↘) n vs)
    un++ₙ r .proj₁ .get i =
      map×⊤ₙ←∘map×⊤ₙ-← n (uncurry⊤ₙ n R) (r .get (↙ i))
    un++ₙ r .proj₂ .get j =
      map×⊤ₙ←∘map×⊤ₙ-← n (uncurry⊤ₙ n R) (r .get (↘ j))

  module _ (b : A → B) (e : B) (a : B → B → B) where

    fold : Vector A s → B
    fold {[-]} u = b (u here)
    fold {ε} u = e
    fold {s <+> t} u = a (fold (u ∘ ↙)) (fold (u ∘ ↘))

  module Sum (0# : A) (_+_ : Op₂ A) where
    ∑ = fold id 0# _+_

  module _ where
    open Setoid
    open IsEquivalence

    setoid : Setoid a ℓ → LTree → Setoid a ℓ
    setoid S s .Carrier = Vector (S .Carrier) s
    setoid S s ._≈_ = Allₙ (S ._≈_)
    setoid S s .isEquivalence .refl .get i = S .refl
    setoid S s .isEquivalence .sym p .get i = S .isEquivalence .sym (p .get i)
    setoid S s .isEquivalence .trans p q .get i =
      S .isEquivalence .trans (p .get i) (q .get i)

    [-]ˢ : ∀ {S} → S ⟶ setoid {a} {ℓ} S [-]
    [-]ˢ ._⟨$⟩_ = [_]
    [-]ˢ .cong = [_]ₙ

    []ˢ : ∀ {S} → ⊤.setoid ⊤ 0ℓ ⟶ setoid {a} {ℓ} S ε
    []ˢ ⟨$⟩ _ = []
    []ˢ .cong _ = []ₙ

    ++ˢ : ∀ {S} →
          ×-setoid (setoid S s) (setoid S t) ⟶ setoid {a} {ℓ} S (s <+> t)
    ++ˢ ⟨$⟩ (xs , ys) = xs ++ ys
    ++ˢ .cong (p , q) = p ++ₙ q

  private
    -- Here's an alternative way to define Allₙ, with less uncurrying.
    -- I haven't decided how it compares to the one I'm actually using.
    -- It is more symmetrical, but I don't know how well it unifies.

    record Allₙ′0 {n as r} {As : Sets n as} (R : Product⊤ n As → Set r)
      {s} (vs : Product⊤ n (smap id (λ A → Vector A s) n As)) : Set r where
      constructor mk
      field get : ∀ (i : Ptr s) → R (map×⊤ₙ← (_$ i) n vs)
    open Allₙ′0  -- public

    Allₙ0 : ∀ {n as r} {As : Sets n as} (R : As ⇉ Set r) {s} →
      smap id (λ A → Vector A s) n As ⇉ Set r
    Allₙ0 {n} R = curry⊤ₙ n (Allₙ′0 (uncurry⊤ₙ n R))

    module _ {n as r} {As : Sets n as} {R : Product⊤ n As → Set r} where

      _++ₙ0_ :
        ∀ {s t} {vs : Product⊤ n (smap id (λ A → Vector A (s <+> t)) n As)} →
        Allₙ′0 R (map×⊤ₙ (_∘ ↙) n vs) → Allₙ′0 R (map×⊤ₙ (_∘ ↘) n vs) →
        Allₙ′0 R vs
      (ru ++ₙ0 rv) .get (↙ i) = map×⊤ₙ←∘map×⊤ₙ-→ n R _ _ _ (ru .get i)
      (ru ++ₙ0 rv) .get (↘ i) = map×⊤ₙ←∘map×⊤ₙ-→ n R _ _ _ (rv .get i)

      _++ₙ⁺0_ :
        ∀ {s t} {us : Product⊤ n (smap id (λ A → Vector A s) n As)}
        {vs : Product⊤ n (smap id (λ A → Vector A t) n As)} →
        Allₙ′0 R us → Allₙ′0 R vs →
        Allₙ′0 R (zipWith×⊤ₙ _++_ us vs)
      _++ₙ⁺0_ {s} {t} ru rv =
        (mk λ i → map×⊤ₙ←∘map×⊤ₙ-← n R (lemma-u R (ru .get i))) ++ₙ0
        (mk λ i → map×⊤ₙ←∘map×⊤ₙ-← n R (lemma-v R (rv .get i)))
        where
        lemma-u : ∀ {n as} {As : Sets n as} (R : Product⊤ n As → Set r)
          {us : Product⊤ n (smap id (λ A → Vector A s) n As)}
          {vs : Product⊤ n (smap id (λ A → Vector A t) n As)} {i} →
          R (map×⊤ₙ← (_$ i) n us) → R (map×⊤ₙ← (_$ ↙ i) n (zipWith×⊤ₙ _++_ us vs))
        lemma-u {zero} R r = r
        lemma-u {suc n} R r = lemma-u {n} (λ xs → R (_ , xs)) r

        lemma-v : ∀ {n as} {As : Sets n as} (R : Product⊤ n As → Set r)
          {us : Product⊤ n (smap id (λ A → Vector A s) n As)}
          {vs : Product⊤ n (smap id (λ A → Vector A t) n As)} {i} →
          R (map×⊤ₙ← (_$ i) n vs) → R (map×⊤ₙ← (_$ ↘ i) n (zipWith×⊤ₙ _++_ us vs))
        lemma-v {zero} R r = r
        lemma-v {suc n} R r = lemma-v {n} (λ xs → R (_ , xs)) r
\end{code}
