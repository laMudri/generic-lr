\begin{code}
{-# OPTIONS --safe --without-K #-}

-- The shape of a binary tree

module Data.LTree where

  open import Data.Bool using (Bool; true; false)
  open import Data.Product as Σ
  open import Relation.Binary.PropositionalEquality
  open import Relation.Nullary
  open import Relation.Nullary.Decidable

  infix 5 _<+>_

  -- A tree is either a box (there), empty, or a pair of trees
\end{code}

%<*LTree>
\begin{code}
  data LTree : Set where
    [-] : LTree
    ε : LTree
    _<+>_ : (s t : LTree) → LTree
\end{code}
%</LTree>

\begin{code}
  private
    variable
      s s′ t : LTree
\end{code}

  -- Pointers to boxes

%<*Ptr>
\begin{code}
  data Ptr : LTree → Set where
    here : Ptr [-]
    ↙ : ∀ {s t} → Ptr s → Ptr (s <+> t)
    ↘ : ∀ {s t} → Ptr t → Ptr (s <+> t)
\end{code}
%</Ptr>

\begin{code}
  private
    example-ltree : LTree
    example-ltree = ([-] <+> [-]) <+> (ε <+> [-])

    example-ptr : Ptr example-ltree
    example-ptr = ↙ (↘ here)

  ↙-injective :
    {i j : Ptr s} → ↙ {t = t} i ≡ ↙ j → i ≡ j
  ↙-injective refl = refl

  ↘-injective :
    {i j : Ptr t} → ↘ {s = s} i ≡ ↘ j → i ≡ j
  ↘-injective refl = refl

  _≟_ : (i j : Ptr s) → Dec (i ≡ j)
  here ≟ here = yes refl
  ↙ i ≟ ↙ j = map′ (cong ↙) ↙-injective (i ≟ j)
  ↙ i ≟ ↘ j = no λ ()
  ↘ i ≟ ↙ j = no λ ()
  ↘ i ≟ ↘ j = map′ (cong ↘) ↘-injective (i ≟ j)

  _==_ : (i j : Ptr s) → Bool
  i == j = does (i ≟ j)
\end{code}
